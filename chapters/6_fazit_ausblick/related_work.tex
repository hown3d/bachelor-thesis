\section{Related Work}
\label{sec:fazit_ausblick:related_work}

In \cite{Truyen2016} beschreiben \citeauthor{Truyen2016}
das Erstellen von \emph{Multi-Tenant}
\acf{SaaS} mithilfe von Containerorchestrierungssoftware wie Kubernetes.
\acp{SaaS} werden immer häufiger auf skalierbaren Plattformen gehostet, um eine hohe Verfügbarkeit sowie Ausfallsicherheit zu gewährleisten.
Innerhalb ihres Papers gehen sie auf die Vor- und Nachteile des Containeransatzes ein.
Ein klarer Vorteil sei die Möglichkeit des Multi-Cloud Modells, da Kubernetes unabhängig der jeweiligen Cloud Anbieter einsetzbar ist.
Isolationsmöglichkeiten zwischen den \emph{Tenants} habe einen hohen Anspruch für Sicherheit und Datenschutz.
Der hohe Aufwand des Managements für die Bereitstellung der Anwendung wird allerdings als problematisch angesehen.
Sie präsentieren eine Referenzarchitektur zum Erstellen von Container basierten Multi-Tenant \acp{SaaS}.
Zum Zeitpunkt ihrer Veröffentlichung bemängeln sie einen fehlenden Standard für Container Images.
Als weiteren Verbesserungspunkt stellen \citeauthor{Truyen2016} drei Möglichkeiten zur Isolation von Tenants vor.
Einen Einsatz des Kubernetes Operator Patterns, welche das Deployment der Anwendung an eine Komponente des \acf{SaaS} übergibt,
wurde in diesem Falle nicht beachtet. Das Operator Pattern wurde 2016 von CoreOS vorgestellt, wodurch zum Erscheinungszeitpunkt
des Papers dieses noch nicht vorhanden war.

\paragraph{}
Als weitere Möglichkeit zur Abstraktion von SoftwareManagement für Endnutzer entwickeln \citeauthor{Wieder2012} in ihrem Paper
\cite{Wieder2012} ein System, das Cloud-Kunden von der Entscheidung der Cloudservicewahl befreit.
Dabei wird speziell auf den Fall von MapReduce Operationen eingegangen. Kunden sollen nur entsprechende Ziele definieren.
Ein Ziel ist dabei beispielsweise die Minimierung der Kosten.
Als Eingabe benötigt das Tool eine Map-Reduce Berechnung, sowie eine Liste von Cloud Services, die in Betracht gezogen werden sollen.
Das System erstellt automatisch die Berechnung und optimiert während der Laufzeit die Anwendung basierend auf externen Zuständen.
\citeauthor{Wieder2012} betrachten in ihrer Arbeit nur den Fall von MapReduce Operationen auf bereits existierenden Services
und nicht die Erstellung eigener Services.

\paragraph{}
Im Paper \cite{Bousselmi2014} wird das \ac{CPP} für \acp{SaaS} beschrieben, welches als Hauptziel die Optimierung der Ressourcennutzung
der Cloudkomponenten sowie die Minimierung der Antwortzeit verfolgt.
Eine gelungene Lösung für das \ac{CPP} solle folgende Anforderungen erfüllen:
\begin{itemize}
  \item \texttt{Platzierungsalgorithmus}
  \item \texttt{Infrastrukturbeschreibung}
  \item \texttt{Provisionierungsalgorithmus}
  \item \texttt{Cloudunabhängig}
\end{itemize}
Kubernetes erfüllt die Anforderungen der Cloudunabhängigkeit, sowie des Platzierungsalgorithmus und Provisionierungsalgorithmus
durch Nutzen des kube-schedulers und sowie die generelle Infrastrukturunabhängigkeit. 
Gaia-X erstellt durch Nutzen der \emph{Self-Descriptions} eine Infrastrukturbeschreibung bezogen auf Ort und genutzter Technologie der Ressourcen.
Desweiteren bieten \citeauthor{Bousselmi2014} eine Übersicht der bereits existierenden Lösungen des \ac{CPP} für \ac{SaaS} Anwendungen.
Hierbei wurde allerdings nur die Nutzung von \acfp{VM} bedacht, welche Nachteile gegenüber Container besitzen.
Da Container nicht zusätzlich Hardware sowie Kernel virtualisieren müssen, kann Rechenkapazität eingespart werden \cite{seo2014performance}.
Außerdem besitzen Container eine bessere Kosteneffizienz sowie Performance im Vergleich zu \acp{VM} \cite{soltesz2007container}.
